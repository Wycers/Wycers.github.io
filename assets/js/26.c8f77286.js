(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{310:function(n,e,t){"use strict";t.r(e);var a=t(2),i=Object(a.a)({},(function(){this._self._c;return this._m(0)}),[function(){var n=this,e=n._self._c;return e("div",{staticClass:"content"},[e("p",[n._v("数据结构与算法分析A Lab 6 A题题解")]),e("h2",{attrs:{id:"description"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#description","aria-hidden":"true"}},[n._v("#")]),n._v(" Description")]),e("p",[n._v("Write a program to print all the leaves of the given tree, numbered from 1 to N.  The root of the tree is node 1.")]),e("h2",{attrs:{id:"input"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#input","aria-hidden":"true"}},[n._v("#")]),n._v(" Input")]),e("p",[n._v("The first line will be an integer T (1≤T≤10), which is the number of test cases.")]),e("p",[n._v("For each test data:")]),e("p",[n._v("The first line contains one integer N (2≤N≤10^4) — the number of the nodes.")]),e("p",[n._v("Each of the next N - 1 lines contain two integers a and b, which means there is an edge between node a and b (1≤a, b≤N).")]),e("h2",{attrs:{id:"output"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#output","aria-hidden":"true"}},[n._v("#")]),n._v(" Output")]),e("p",[n._v("For each case please, print all the leaves of the given tree, in ascending order.")]),e("p",[n._v("For the tree has multiple leaf nodes, there is a blank between two leaf nodes, and ‘\\n’ at the end of each line.")]),e("h3",{attrs:{id:"sample-input"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sample-input","aria-hidden":"true"}},[n._v("#")]),n._v(" Sample Input")]),e("p",[n._v("1\n4\n1 2\n2 3\n3 4")]),e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("### Sample Output\n")])]),e("p",[n._v("4")]),e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('\n## 思路\n\n题意是给出一棵树，问其所有的叶子的编号。\n\n注意点1一定算根不算叶子。\n\n\n## Solution\n\n其实只要判断度就好了，这个有点麻烦……\n\n### Code\n``` cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int N = 1e4 + 10;\nint n;\nstruct Edge\n{\n    int to, next;\n} edge[N << 1];\nint head[N], cnt = 0;\nvoid insert(int u, int v)\n{\n    edge[++cnt] = (Edge){v, head[u]};\n    head[u] = cnt;\n}\nvector<int> ans;\nvoid dfs(int now, int fa)\n{\n    bool flag = true;\n    for (int i = head[now]; i; i = edge[i].next)\n    {\n        int v = edge[i].to;\n        if (v == fa)\n            continue;\n        dfs(v, now);\n        flag = false;\n    }\n    if (flag && now != 1)\n        ans.push_back(now);\n}\nvoid solve()\n{\n    memset(head, 0, sizeof head); cnt = 0;\n    ans.clear();\n    scanf("%d", &n);\n    for (int i = 1; i < n; ++i)\n    {\n        int x, y;\n        scanf("%d%d", &x, &y);\n        insert(x, y);\n        insert(y, x);\n    }\n    dfs(1, 0);\n    sort(ans.begin(), ans.end());\n    for (int i = 0, len = ans.size(); i < len; ++i)\n        printf("%d ", ans[i]);\n    puts("");\n}\nint main()\n{\n    int T; scanf("%d", &T);\n    while (T--)\n        solve();\n    return 0;\n}\n')])])])}],!1,null,null,null);e.default=i.exports}}]);